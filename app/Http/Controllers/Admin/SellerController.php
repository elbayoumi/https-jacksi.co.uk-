<?php

namespace App\Http\Controllers\Admin;

use App\Http\Controllers\Controller;
use App\Http\Requests\Admin\StoreSellerRequest;
use App\Http\Requests\Admin\UpdateSellerRequest;
use App\Models\Seller;
use Illuminate\Contracts\View\View;
use Illuminate\Http\JsonResponse;
use Illuminate\Http\RedirectResponse;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\Hash;

/**
 * Class SellerController
 *
 * Admin-facing controller for managing sellers.
 * - Protected by the "admin" guard to ensure only administrators can access.
 * - Provides a paginated listing endpoint with filters and sorting.
 * - Allows creating/updating sellers and toggling activation.
 * - Optional destroy() for deleting a seller (use with caution; soft deletes recommended).
 *
 * Notes:
 * - Keep controllers slim: this controller intentionally avoids complex business logic.
 *   If you need more rules (audit logs, notifications, etc.), consider introducing a
 *   dedicated AdminSellerService and inject it here via the constructor.
 */
class SellerController extends Controller
{
    /**
     * Enforce the admin guard for all actions.
     */
    public function __construct()
    {
        $this->middleware('auth:admin');
    }

    /**
     * Display a paginated and filterable list of sellers.
     *
     * Supports HTML (Blade) and JSON responses:
     * - HTML: returns the "admin.sellers.index" view.
     * - JSON: returns { data: [], meta: {} } structure suitable for dashboards or AJAX.
     *
     * Query parameters:
     * - q:         optional search term (matches name/email).
     * - status:    optional filter "active" | "inactive".
     * - sort:      optional field to sort by (default: id).
     * - dir:       optional direction "asc" | "desc" (default: desc).
     * - per_page:  optional page size (default: 15).
     */
    public function index(Request $request): View|JsonResponse
    {
        // Extra safety: ensure we really have an authenticated admin
        $admin = Auth::guard('admin')->user();
        abort_unless($admin, 401);

        $q        = (string) $request->query('q', '');
        $status   = (string) $request->query('status', '');
        $sort     = (string) $request->query('sort', 'id');
        $dir      = strtolower((string) $request->query('dir', 'desc')) === 'asc' ? 'asc' : 'desc';
        $perPage  = (int) $request->query('per_page', 15);
        $perPage  = $perPage > 0 && $perPage <= 100 ? $perPage : 15;

        $query = Seller::query();

        // Search by name or email
        if ($q !== '') {
            $query->where(function ($qBuilder) use ($q) {
                $qBuilder->where('name', 'like', "%{$q}%")
                    ->orWhere('email', 'like', "%{$q}%");
            });
        }

        // Filter by activation status
        if ($status === 'active') {
            $query->where('is_active', true);
        } elseif ($status === 'inactive') {
            $query->where('is_active', false);
        }

        // Whitelist sortable columns to prevent SQL injection in orderBy
        $sortable = ['id', 'name', 'email', 'is_active', 'created_at'];
        if (! in_array($sort, $sortable, true)) {
            $sort = 'id';
        }

        $sellers = $query->orderBy($sort, $dir)
            ->paginate($perPage)
            ->withQueryString();

        if ($request->wantsJson()) {
            return response()->json([
                'data' => $sellers->items(),
                'meta' => [
                    'current_page' => $sellers->currentPage(),
                    'last_page'    => $sellers->lastPage(),
                    'per_page'     => $sellers->perPage(),
                    'total'        => $sellers->total(),
                    'sort'         => $sort,
                    'dir'          => $dir,
                    'filters'      => [
                        'q'      => $q,
                        'status' => $status,
                    ],
                ],
            ]);
        }

        return view('admin.sellers.index', compact('sellers', 'q', 'status', 'sort', 'dir'));
    }

    /**
     * Store a new seller.
     *
     * Accepts JSON and form submissions. A dedicated FormRequest
     * (StoreSellerRequest) handles validation and messages.
     *
     * Typical payload (JSON or form):
     * {
     *   "name": "Seller Name",
     *   "email": "seller@mail.com",
     *   "password": "secret123",      // optional; if omitted, a random one should be generated by the UI or you can generate here
     *   "is_active": true
     * }
     *
     * Returns:
     * - JSON: { message, data }
     * - HTML: redirects back with flash status
     */
    public function store(StoreSellerRequest $request): RedirectResponse|JsonResponse
    {
        $data = $request->validated();

        // Hash password if provided; if it's nullable in the request,
        // you may want to enforce non-null in StoreSellerRequest.
        if (! empty($data['password'])) {
            $data['password'] = Hash::make($data['password']);
        } else {
            // For safety, enforce a random password when not provided
            // (or you can reject the request in the FormRequest).
            $data['password'] = Hash::make(str()->random(12));
        }

        $seller = Seller::create([
            'name'      => $data['name'],
            'email'     => $data['email'],
            'password'  => $data['password'],
            'is_active' => $data['is_active'] ?? true,
        ]);

        // If you plan to notify the seller with credentials, do it here (mail/notification/queue).

        return $this->respond($request, $seller->fresh(), 'Seller created successfully.');
    }

    /**
     * Update a seller record.
     *
     * Supports two modes:
     *  1) Toggle activation via `?action=toggle` (flips the `is_active` flag).
     *  2) Standard attribute update using validated payload (name, email, is_active, password?).
     *
     * Responds with JSON for API/AJAX requests or redirects back for HTML.
     *
     * Examples:
     *  - PATCH /admin/sellers/5?action=toggle
     *  - PATCH /admin/sellers/5  { "is_active": false }
     *  - PATCH /admin/sellers/5  { "name": "New Name", "email": "new@mail.com" }
     */
    public function update(UpdateSellerRequest $request, Seller $seller): RedirectResponse|JsonResponse
    {
        // --- Mode 1: Toggle activation -------------------------------------------------
        $action = (string) $request->query('action', '');
        if ($action === 'toggle') {
            $seller->forceFill(['is_active' => ! (bool) $seller->is_active])->save();
            return $this->respond($request, $seller->fresh(), 'Seller activation state toggled.');
        }

        // --- Mode 2: Standard update ---------------------------------------------------
        $data = $request->validated();

        // Apply only provided attributes; avoid unintended mass assignment.
        $updatable = ['name', 'email', 'is_active'];
        foreach ($updatable as $attr) {
            if (array_key_exists($attr, $data)) {
                $seller->{$attr} = $data[$attr];
            }
        }

        // Optional: password rotation from admin panel
        if (array_key_exists('password', $data) && ! empty($data['password'])) {
            $seller->password = Hash::make($data['password']);
        }

        // Save only if something actually changed to prevent unnecessary writes.
        if ($seller->isDirty()) {
            $seller->save();
            return $this->respond($request, $seller->fresh(), 'Seller updated successfully.');
        }

        // No-op update (nothing changed).
        return $this->respond($request, $seller, 'No changes were applied.');
    }

    /**
     * Delete a seller (and potentially cascade related records).
     *
     * WARNING:
     * - Consider soft deletes for auditability and to prevent accidental data loss.
     * - If the business model requires cascading deletions (clients/invoices),
     *   ensure foreign keys are set with ON DELETE CASCADE or handle manually.
     */
    public function destroy(Request $request, Seller $seller): RedirectResponse|JsonResponse
    {
        // In many systems, deleting sellers is restricted. Adjust policy as needed.
        $seller->delete();

        return $this->respond($request, $seller, 'Seller deleted successfully.');
    }

    /**
     * Respond with JSON for API/AJAX or redirect back for HTML requests.
     */
    protected function respond(Request $request, Seller $seller, string $message): RedirectResponse|JsonResponse
    {
        if ($request->wantsJson()) {
            return response()->json([
                'message' => $message,
                'data'    => $seller->fresh(),
            ]);
        }

        return back()->with('status', $message);
    }
}
